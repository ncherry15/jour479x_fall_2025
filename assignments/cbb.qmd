## Regression
```{r}
library(tidyverse)
library(Hmisc)
```
```{r}
logs <- read_csv("https://dwillis.github.io/sports-data-files/cbblogs1525.csv")
```
```{r}
logs <- logs |> mutate(
  Differential = TeamScore - OpponentScore, 
  NetRebounds = TeamTotalRebounds - OpponentTotalRebounds,
  TurnoverMargin = TeamTurnovers - OpponentTurnovers)
```
```{r}
rebounds <- lm(Differential ~ NetRebounds, data=logs)
summary(rebounds)
```
```{r}
model1 <- lm(Differential ~ NetRebounds + TurnoverMargin, data=logs)
summary(model1)
```
```{r}
install.packages("Hmisc")
```
```{r}
simplelogs <- logs |> select_if(is.numeric) |> select(-Game) |> select(Differential, NetRebounds, TurnoverMargin, TeamFGPCT, TeamTotalRebounds, OpponentFGPCT, OpponentTotalRebounds)

cormatrix <- rcorr(as.matrix(simplelogs))

cormatrix$r
```
```{r}
model2 <- lm(Differential ~ NetRebounds + TurnoverMargin + TeamFGPCT + OpponentFGPCT, data=logs)
summary(model2)
```
```{r}
logs |> 
  filter(Team == "Michigan" & Season == '2020-2021' | Team == "Wisconsin" & Season == '2019-2020' | Team == "Michigan State" & Season == '2018-2019' | Team == "Michigan State" & Season == '2017-2018' | Team == 'Illinois' & Season == '2021-2022' | Team == 'Purdue' & Season == '2022-2023' | Team == 'Purdue' & Season == '2023-2024' | Team == "Michigan State" & Season == '2024-2025') |> 
  summarise(
    meanNetRebounds = mean(NetRebounds),
    meanTurnoverMargin = mean(TurnoverMargin),
    meanTeamFGPCT = mean(TeamFGPCT),
    meanOpponentFGPCT = mean(OpponentFGPCT)
  )
```
```{r}
# (netrebounds estimate * meanNetRebounds) + (turnover margin estimate * meanTurnoverMargin) + (TeamFGPCT estimate * meanTeamFGPCT) + (OpponentFGPCT estimate * meanOpponentFGPCT) + Intercept
(0.660276*9.432099) + (-1.315355*1.711934) + (91.472656*0.4745391) + (-91.705986*0.4000823) + 0.230468
```

```{r}
logs |> 
  filter(
    Team == "Maryland" & Season == '2024-2025'
    ) |> 
  summarise(
    meanNetRebounds = mean(NetRebounds),
    meanTurnoverMargin = mean(TurnoverMargin),
    meanTeamFGPCT = mean(TeamFGPCT),
    meanOpponentFGPCT = mean(OpponentFGPCT)
  )
```
```{r}
(0.660276*2.472222) + (-1.315355*-3.444444) + (91.472656*0.4687778) + (-91.705986*0.4150278) + 0.230468
```
```{r}
logs |> 
     filter(
         Team == "Maryland" & Season == '2024-2025'
     ) |> summarise(avg_score = mean(TeamScore), avg_opp = mean(OpponentScore))
```

## My new model
I think a good alternative model would predict a team’s offensive efficiency or points per possession. I’d use predictors like FGPct, Offensive Rebounds, Turnovers, and FTAs, all of which directly influence scoring per trip.This could show whether shooting accuracy, second-chance opportunities, or ball security matters most for putting points on the board.
One challenge is that some of these stats are correlated, so it could make it harder to isolate each variable’s impact.

I used chatgpt to create a formula to figure out possesions: https://chatgpt.com/share/68d5875c-1a3c-8012-87a8-0b78d97b5962 

```{r}
logs <- logs |> 
  mutate(
    possessions = TeamFGA + 0.44 * TeamFTA - TeamOffRebounds + TeamTurnovers,
    offensive_efficiency = TeamScore / possessions
  )

model3 <- lm(
  offensive_efficiency ~ TeamFGPCT + TeamOffRebounds + TeamTurnovers + TeamFTA,
  data = logs
)

summary(model3)
```
The model explains about 88% of the variation in offensive efficiency, indicating that these four stats capture most of what drives scoring per possession. FGPct has the largest positive effect, meaning that even small improvements in shooting accuracy can meaningfully increase offensive efficiency. Offensive rebounds and FTAs also contribute positively, showing that extending possessions and earning points from the line are important, while turnovers have a clear negative effect. I expected this as losing the ball reduces any scoring opportunity. All predictors are highly significant, but because some of them are related (for example, better shooting might lead to fewer offensive rebounds), there could be some overlap in the information the variables provide. This slightly inflates standard errors, though the overall relationships remain strong and intuitive.

```{r}
maryland_games <- logs |>
  filter(
    TeamFull == "Maryland Terrapins Men's",
    Season == "2024-2025",
    Date %in%  c("2024-11-15", "2024-12-08", "2025-01-10","2025-02-16","2025-03-15")
  )

maryland_games |>
  select(Date, TeamFGPCT, TeamOffRebounds, TeamTurnovers, TeamFTA)

maryland_games |>
  mutate(
    predicted_efficiency =
      0.2252 +
      1.867   * TeamFGPCT +
      0.01214 * TeamOffRebounds +
     -0.01518 * TeamTurnovers +
      0.003214 * TeamFTA
  ) |> 
  select(Date, offensive_efficiency, predicted_efficiency)
```
I would say my model performs well overall. Across the five Maryland games, its predicted offensive efficiency stays within roughly 0.01 to 0.05 points per possession of the actual values. This consistency shows that shooting percentage, offensive rebounds, turnovers, and free throws capture the key elements of scoring efficiency.Incorporating factors like opponent defensive quality or player-level metrics could further refine the predictions and narrow the remaining gaps.

##Z-Scores
```{r}
gamelogs <- read_csv("/Users/lornizzle/Downloads/logs25.csv")
```
```{r}
teamquality <- gamelogs |> 
  select(Conference, Team, TeamFGPCT, TeamTotalRebounds, OpponentFGPCT, OpponentTotalRebounds)

teamtotals <- teamquality |> 
  group_by(Conference, Team) |> 
  summarise(
    FGAvg = mean(TeamFGPCT), 
    ReboundAvg = mean(TeamTotalRebounds), 
    OppFGAvg = mean(OpponentFGPCT),
    OffRebAvg = mean(OpponentTotalRebounds)
    ) 
```
```{r}
teamzscore <- teamtotals |> 
  mutate(
    FGzscore = as.numeric(scale(FGAvg, center = TRUE, scale = TRUE)),
    RebZscore = as.numeric(scale(ReboundAvg, center = TRUE, scale = TRUE)),
    OppZscore = as.numeric(scale(OppFGAvg, center = TRUE, scale = TRUE)) * -1,
    OppRebZScore = as.numeric(scale(OffRebAvg, center = TRUE, scale = TRUE)) * -1,
    TotalZscore = FGzscore + RebZscore + OppZscore + OppRebZScore
  )  

head(teamzscore)
```
```{r}
teamzscore |> arrange(desc(TotalZscore))
```
```{r}
teamzscore |> 
  filter(Conference == "Big Ten MBB") |> 
  arrange(desc(TotalZscore)) |>
  select(Team, TotalZscore)
```

```{r}
powerfive_plus_one <- c("SEC MBB", "Big Ten MBB", "Pac-12 MBB", "Big 12 MBB", "ACC MBB", "Big East MBB")
teamzscore |> 
  filter(Conference %in% powerfive_plus_one) |> 
  arrange(desc(TotalZscore)) |>
  select(Team, TotalZscore)
```
## Clustering
```{r}
library(tidyverse)
library(cluster)

set.seed(1234)
```

```{r}
players <- read_csv("https://dwillis.github.io/sports-data-files/players25.csv")
```
```{r}
playersselected <- players |>
  filter(MP>0) |> filter(Pos == "C") |>
  select(Player, Team, Pos, MP, `FG%`, TRB, BLK, TOV, PTS) |>
  na.omit()
```
```{r}
playersscaled <- playersselected |>
  select(MP, `FG%`, TRB, BLK, TOV, PTS) |>
  mutate_all(scale) |>
  na.omit()
```
```{r}
# function to compute total within-cluster sum of square
wss <- function(k) {
  kmeans(playersscaled, k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

plot(k.values, wss_values,
       type="b", pch = 19, frame = FALSE,
       xlab="Number of clusters K",
       ylab="Total within-clusters sum of squares")
```
```{r}
k8 <- kmeans(playersscaled, centers = 8, nstart = 25)
k8
```
```{r}
playercluster <- data.frame(playersselected, k8$cluster)
```
```{r}
dq <- playercluster |> filter(Player == "Derik Queen")

dq
```
```{r}
ggplot() +
  geom_point(data=playercluster, aes(x=MP, y=TRB, color=k8.cluster)) +
  geom_point(data=dq, aes(x=MP, y=TRB), color="red")
```
```{r}
#big10 <- c("Nebraska Cornhuskers", "Iowa Hawkeyes", "Minnesota Golden Gophers", "Illinois Fighting Illini", "Northwestern Wildcats", "Wisconsin Badgers", "Indiana Hoosiers", "Purdue Boilermakers", "Ohio State Buckeyes", "Michigan Wolverines", "Michigan State Spartans", "Penn State Nittany Lions", "Rutgers Scarlet Knights", "Maryland Terrapins")

playercluster |> filter(k8.cluster == 1) |> arrange(desc(MP))
```
